/*
 * Secret Server
 *
 * This is an API of a secret service. You can save your secret by using the API. You can restrict the access of a secret after the certen number of views or after a certen period of time.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package server

import (
	"context"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	"github.com/jakule/codersranktask/internal"
	"github.com/jakule/codersranktask/internal/storage"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"go.uber.org/zap"
)

type Route struct {
	Name        string
	Method      string
	Pattern     string
	HandlerFunc paramHandler
}

type paramHandler func(c *internal.CallParams, w http.ResponseWriter, r *http.Request)

type Routes []Route

var routes = Routes{
	Route{
		"Index",
		"GET",
		"/v1/",
		Index,
	},

	Route{
		"AddSecret",
		"POST",
		"/v1/secret",
		AddSecret,
	},

	Route{
		"GetSecretByHash",
		"GET",
		"/v1/secret/{hash}",
		GetSecretByHash,
	},
}

var (
	// counter counts incoming requests
	counter = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "secretserver_requests_total",
			Help: "A counter for requests to the wrapped handler.",
		},
		[]string{"code", "method"},
	)

	// duration is partitioned by the HTTP method and handler. It uses custom
	// buckets based on the expected request duration.
	duration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "secretserver_request_duration_seconds",
			Help:    "A histogram of latencies for requests.",
			Buckets: []float64{.25, .5, 1, 2.5, 5, 10},
		},
		[]string{"handler", "method"},
	)

	// reqDurations is a summary to track fictional latencies for three
	// distinct services with different latency distributions.
	reqDurations = prometheus.NewSummaryVec(
		prometheus.SummaryOpts{
			Name:       "secretserver_request_response_seconds",
			Help:       "Request latency distributions.",
			Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
		},
		[]string{"handler", "method"},
	)
)

func handlerWrapperLogger(params *internal.CallParams, inner paramHandler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		inner(params, w, r)
	})
}

func newCallParams(dbConnStr string) *internal.CallParams {
	s, err := storage.NewPgStorage(dbConnStr)
	if err != nil {
		panic(err)
	}
	return internal.NewCallParams(context.Background(),
		mustLogger(newProdLogger()).Sugar(), s)
}

func newProdLogger() (*zap.Logger, error) {
	return zap.NewProduction()
}

func mustLogger(logger *zap.Logger, err error) *zap.Logger {
	if err != nil {
		panic(err)
	}
	return logger
}

func NewRouter(dbConnStr string) *mux.Router {
	router := mux.NewRouter().StrictSlash(true)
	prometheus.MustRegister(counter)
	prometheus.MustRegister(duration)
	prometheus.MustRegister(reqDurations)

	for _, route := range routes {
		callParams := newCallParams(dbConnStr)
		handler := handlerWrapperLogger(callParams, route.HandlerFunc)
		handler = internal.Logger(callParams, handler, route.Name)

		handler = promhttp.InstrumentHandlerDuration(
			reqDurations.MustCurryWith(prometheus.Labels{
				"handler": strings.ToLower(route.Name),
			}), handler)
		handler = promhttp.InstrumentHandlerDuration(
			duration.MustCurryWith(prometheus.Labels{
				"handler": strings.ToLower(route.Name),
			}), handler)
		handler = promhttp.InstrumentHandlerCounter(counter, handler)

		router.
			Methods(route.Method).
			Path(route.Pattern).
			Name(route.Name).
			Handler(handler)
	}

	// Register Prometheus endpoint
	router.Name("metrics").Handler(promhttp.Handler())

	return router
}
